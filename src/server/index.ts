import express from 'express'
import cors from 'cors'
import { prisma } from './lib/prisma'
import { authRouter } from './routes/auth'
import { riskSheetsRouter } from './routes/riskSheets'
import { evaluationsRouter } from './routes/evaluations'
import { responsesRouter } from './routes/responses'
import { templatesRouter } from './routes/templates'
import { notificationsRouter } from './routes/notifications'
import { actionsRouter } from './routes/actions'
import { correlationsRouter } from './routes/correlations'
import { auditRouter } from './routes/audit'
import { tenantsRouter } from './routes/tenants'
import { usersRouter } from './routes/users'
import { analyticsRouter } from './routes/analytics'
import ragRoutes from './routes/rag'
import { NotificationScheduler } from './services/notificationScheduler'

const app = express()
const PORT = process.env.PORT || 3002

// Middleware de base
app.use(cors({
  origin: [
    process.env.FRONTEND_URL || 'http://localhost:5174',
    'http://localhost:5173'
  ],
  credentials: true
}))

app.use(express.json({ limit: '10mb' }))
app.use(express.urlencoded({ extended: true }))

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    services: {
      database: 'connected',
      rag: 'active',
      notifications: 'active'
    }
  })
})

// Route de test simple
app.get('/api/test', (req, res) => {
  res.json({ 
    message: 'API fonctionne !', 
    timestamp: new Date().toISOString(),
    endpoints: {
      auth: '/api/auth',
      rag: '/api/rag',
      evaluations: '/api/evaluations',
      risks: '/api/risk-sheets',
      actions: '/api/actions'
    }
  })
})

// Routes API
app.use('/api/auth', authRouter)
app.use('/api/rag', ragRoutes)
app.use('/api/risk-sheets', riskSheetsRouter)
app.use('/api/evaluations', evaluationsRouter)
app.use('/api/evaluations', responsesRouter)
app.use('/api/templates', templatesRouter)
app.use('/api/notifications', notificationsRouter)
app.use('/api/actions', actionsRouter)
app.use('/api/correlations', correlationsRouter)
app.use('/api/audit', auditRouter)
app.use('/api/tenants', tenantsRouter)
app.use('/api/users', usersRouter)
app.use('/api/analytics', analyticsRouter)

// RAG system status endpoint
app.get('/api/rag-status', (req, res) => {
  res.json({
    status: 'active',
    service: 'mock-chromadb',
    endpoints: {
      query: '/api/rag/query',
      index: '/api/rag/index',
      status: '/api/rag/status'
    },
    timestamp: new Date().toISOString()
  })
})

// Middleware de gestion d'erreurs am√©lior√©
app.use((err: any, req: any, res: any, next: any) => {
  console.error('‚ùå Erreur serveur:', {
    message: err.message,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined,
    url: req.originalUrl,
    method: req.method,
    timestamp: new Date().toISOString()
  })

  // Erreurs sp√©cifiques au RAG
  if (err.message?.includes('RAG') || err.message?.includes('embedding')) {
    return res.status(503).json({
      error: 'Service RAG temporairement indisponible',
      message: 'Le syst√®me d\'IA est en cours de maintenance',
      code: 'RAG_SERVICE_ERROR'
    })
  }

  // Erreurs de base de donn√©es
  if (err.message?.includes('Prisma') || err.message?.includes('database')) {
    return res.status(503).json({
      error: 'Service de base de donn√©es indisponible',
      message: 'Probl√®me de connexion √† la base de donn√©es',
      code: 'DATABASE_ERROR'
    })
  }

  // Erreur g√©n√©rique
  res.status(500).json({
    error: 'Erreur interne du serveur',
    message: process.env.NODE_ENV === 'development' ? err.message : 'Une erreur est survenue',
    code: 'INTERNAL_SERVER_ERROR',
    timestamp: new Date().toISOString()
  })
})

// Route 404 am√©lior√©e
app.use('*', (req, res) => {
  console.log(`‚ùì Route non trouv√©e: ${req.method} ${req.originalUrl}`)
  
  res.status(404).json({
    error: 'Route non trouv√©e',
    path: req.originalUrl,
    method: req.method,
    availableEndpoints: [
      '/api/auth/login',
      '/api/rag/query',
      '/api/rag/index',
      '/api/rag/status',
      '/api/evaluations',
      '/api/risk-sheets',
      '/api/actions',
      '/health'
    ],
    timestamp: new Date().toISOString()
  })
})

// D√©marrage du serveur am√©lior√©
const startServer = async () => {
  try {
    console.log('üöÄ D√©marrage du serveur GAMR...')
    
    // Test de connexion √† la base de donn√©es
    await prisma.$connect()
    console.log('‚úÖ Connexion √† la base de donn√©es √©tablie')

    // Initialiser le syst√®me RAG
    console.log('ü§ñ Initialisation du syst√®me RAG...')
    console.log('‚úÖ Syst√®me RAG pr√™t (mode mock pour d√©veloppement)')

    // D√©marrer le planificateur de notifications
    const notificationScheduler = NotificationScheduler.getInstance()
    notificationScheduler.start(30)
    console.log('üîî D√©marrage du planificateur de notifications (intervalle: 30 minutes)')
    console.log('üîç V√©rification des notifications automatiques...')
    console.log('‚úÖ Planificateur de notifications actif')

    app.listen(PORT, () => {
      console.log('\nüéâ Serveur GAMR d√©marr√© avec succ√®s!')
      console.log(`üìç URL: http://localhost:${PORT}`)
      console.log(`üìä Health check: http://localhost:${PORT}/health`)
      console.log(`ü§ñ RAG API: http://localhost:${PORT}/api/rag`)
      console.log(`üîî Notifications: Actives`)
      console.log(`üõ°Ô∏è CORS: Configur√© pour localhost:5173 et localhost:5174`)
      console.log('\nüìã Endpoints disponibles:')
      console.log('  ‚Ä¢ POST /api/auth/login')
      console.log('  ‚Ä¢ POST /api/rag/query')
      console.log('  ‚Ä¢ POST /api/rag/index')
      console.log('  ‚Ä¢ GET  /api/rag/status')
      console.log('  ‚Ä¢ GET  /api/evaluations')
      console.log('  ‚Ä¢ GET  /api/risk-sheets')
      console.log('  ‚Ä¢ GET  /api/actions')
      console.log('\nüî• Pr√™t √† recevoir des requ√™tes!')
    })
  } catch (error) {
    console.error('‚ùå Erreur lors du d√©marrage du serveur:', error)
    
    if (error instanceof Error) {
      console.error('Message:', error.message)
      console.error('Stack:', error.stack)
    }
    
    process.exit(1)
  }
}

// Gestion propre de l'arr√™t am√©lior√©e
const gracefulShutdown = async (signal: string) => {
  console.log(`\nüõë Signal ${signal} re√ßu - Arr√™t gracieux du serveur...`)

  try {
    // Arr√™ter le planificateur de notifications
    const notificationScheduler = NotificationScheduler.getInstance()
    notificationScheduler.stop()
    console.log('‚úÖ Planificateur de notifications arr√™t√©')

    // Fermer la connexion √† la base de donn√©es
    await prisma.$disconnect()
    console.log('‚úÖ Connexion √† la base de donn√©es ferm√©e')

    console.log('üëã Serveur arr√™t√© proprement')
    process.exit(0)
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'arr√™t:', error)
    process.exit(1)
  }
}

process.on('SIGINT', () => gracefulShutdown('SIGINT'))
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'))

// Gestion des erreurs non captur√©es
process.on('uncaughtException', (error) => {
  console.error('‚ùå Exception non captur√©e:', error)
  process.exit(1)
})

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Promesse rejet√©e non g√©r√©e:', reason)
  console.error('Promise:', promise)
  process.exit(1)
})

// D√©marrer le serveur
startServer()

export { app }